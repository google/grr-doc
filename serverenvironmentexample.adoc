GRR Server Environment Example Setup
====================================
:toc:
:toc-placement: preamble
:icons:

A GRR Server Environment can be whatever you make it. This example goes over the
steps necessary to a three server environment: one to house the front end HTTP
service, one to house the master datastore, and one to house the admin ui and
workers.

Assumptions Made
----------------
Below are the assumptions made to make use of this example.

* GRR Servers will be running Ubuntu 16.04 LTS with all updates already installed
* There will be 3 servers in the configuration as outlined above. They will be called Master Dataserver, HTTP Server, and Main Server
* Bleeding edge GRR is desired and will be installed via pip
* The virtual environment will be called GRR_NEW
* All networking has been properly set up

Setting up the servers
----------------------
The steps below are based off of
https://github.com/google/grr-doc/blob/master/installfrompip.adoc[Install from
Pip] documentation. If the below does not work, please refer back to there.

1. `apt-get install debhelper dpkg-dev libssl-dev python-dev python-pip rpm git
protobuf-compiler`
2. `pip install --upgrade pip`
3. `pip install virtualenv`
4. `git clone https://github.com/google/grr.git`
5. `virtualenv GRR_NEW`
6. `source GRR_NEW/bin/activate`
7. `cd grr/`
8. `pip install --editable .`
9. `pip install --editable grr/config/grr-response-server`
10. `pip install --no-cache-dir -f
https://storage.googleapis.com/releases.grr-response.com/index.html
grr-response-templates`
11. `pip install --editable grr/config/grr-response-test`

Configuring GRR on the Main Server
----------------------------------
1. Set up a MTA of your choice
2. Run `grr_config_updater initialize`
* Step 1: Key Generation: - this step autocompletes and needs no user input
* Step 2: Setting Basic Configuration Parameters:
    - GRR Datastore: Choose `1` for a SQLite Datastore. That is the datastore
      all these tutorials assume you have
    - GRR URLs: Enter hostname: `<main server ip>`
    - Server URL: Frontend URL `http://<http server ip>:8080/`
    - AdminUI URL: leave as default, press enter
    - GRR Emails: Email Domain: `<your email domain>`
    - GRR Emails: Alert Email Address: `<your alerts email>`
    - GRR Emails: Emergency Email Access Email Address: `<your emergency email>`
* Step 3: Adding Admin User: `<password>`
* Step 4: Installing template package: `n`
* Step 5: - Completes on its own
3. _Optional_ - Edit `grr/install_data/etc/server.local.yaml` and move
`PrivateKeys.executable_signing_private_key` key to a new file and change permissions
based on your executable signing structure policy
4. _Optional_ - Set up the Approval Process
* Users listed in the approval process will be added later. However this configuration must be pushed out to all servers, so it should be set up now.
* https://github.com/google/grr-doc/blob/master/admin.adoc#auditing[Auditing]

Initial Configuration on HTTP Server
------------------------------------
1. Replace `grr/install_data/etc/server.local.yaml` and
`grr/install_data/etc/grr-server.yaml` with the files from main server

Configuration on Master Dataserver
----------------------------------
1. Replace `grr/install_data/etc/server.local.yaml` and
`grr/install_data/etc/grr-server.yaml` with the files from main server
2. Edit `grr/install_data/etc/server.local.yaml` and add the following:
+
[source,yaml]
Datastore.location: <full path to datastore>
Dataserver.server_list:
  - http://<dataserver ip>:7000
Dataserver.client_credentials:
  - <client_username>:<client_password>:rw
Dataserver.server_username: <server_username>
Dataserver.server_password: <server_password>

* Terms:
    - `server_list` is a list of all database servers with the master listed
      first
    - `client_credentials` are used for the http server and main server to
      communicate with the database
    - `server_username` and `server_password` are used for any slave dataservers
      to talk to the master dataserver.
3. Start the dataserver service by running `grr_server --component
dataserver_master`
* It should start with no errors and not show any information. If you would
 like to see more information add in `--verbose`

Finish the Configuration on the Main Server
-------------------------------------------
1. Edit install_data/etc/server.local.yaml
* Dataserver Configuration:
+
[source,yaml]
Dataserver.server_list:
   - http://<dataserver ip>:7000
Datastore.implementation: HTTPServer
HTTPDatastore.username: <client_username>
HTTPDatastore.password: <client_password>

* Email Configuration:
+
[source,yaml]
Worker.smtp_server: <smtp server>
Worker.smtp_port: 587
Worker.smtp_starttle: True
Worker.smtp_user: <username>
Worker.smtp_password: <password>
Email.approval_cc_address: <monitoring email>

* *Note* `approval_cc_address` should only be the account name, your email
 domain will be appended later.
* Private Key configuration 
+
[source,yaml]
PrivateKeys.executable_signing_private_key: "%(<path to key>|file)"

2. Add users who should be able to access the admin interface.
* *Note* Users cannot change their password in the admin ui, they must change
 it in the command line
* https://github.com/google/grr-doc/blob/master/admin.adoc#user-management[User
 Management]
3. Run `grr_config_updater repack_clients`
* *Note* -If you decided to implement #3 in Configuring GRR on the Main Server
 add `--secondary_configs <signing key file>` after `grr_config_updater`
4. Start services with `grr_server --component worker and grr_server --component
ui`

Finish the configuration on HTTP Server
---------------------------------------
1. Edit `install_data/etc/server.local.yaml`
+
[source,yaml]
Dataserver Configuration:
Dataserver.server_list:
   - http://<dataserver ip>:7000
Datastore.implementation: HTTPServer
HTTPDatastore.username: <client_username>
HTTPDatastore.password: <client_password>

2. Start services with `grr_server --component http_server`

Post Setup
---------
At this point, you should be able to visit your admin interface, download the
appropriate client installer binary. Once that is installed on the client, it
will communicate back to your HTTP server and be visible through the admin ui.
